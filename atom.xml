<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chiahsien.github.io</id>
    <title>Nelson</title>
    <updated>2020-09-13T07:51:49.314Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chiahsien.github.io"/>
    <link rel="self" href="https://chiahsien.github.io/atom.xml"/>
    <subtitle>iOS Dev / Manager 的一些心得與筆記</subtitle>
    <logo>https://chiahsien.github.io/images/avatar.png</logo>
    <icon>https://chiahsien.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Nelson</rights>
    <entry>
        <title type="html"><![CDATA[第三方 Kobo 閱讀軟體：KOReader & Plato]]></title>
        <id>https://chiahsien.github.io/post/alternative-kobo-e-reader-koreader-and-plato/</id>
        <link href="https://chiahsien.github.io/post/alternative-kobo-e-reader-koreader-and-plato/">
        </link>
        <updated>2020-09-13T07:46:36.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="為何需要第三方閱讀軟體">為何需要第三方閱讀軟體</h4>
<p>Kobo 閱讀器內建的軟體在閱讀它們自家電子書的表現，其實已經很符合絕大多數人的需求了。但如果你有以下需求，就會想要尋找更強大的閱讀軟體：</p>
<ul>
<li>想放其他的電子書進去：如果那本電子書排版沒有設計得很好，加上內建的閱讀軟體可調整的選項不多，這樣讀起來就會有些痛苦。</li>
<li>想要閱讀 PDF 檔：很多 PDF 檔四周會留下不少空白，它又不能調整文字大小，甚至有的 PDF 是兩欄或三欄的排版，在十吋以下的螢幕閱讀會非常辛苦。由於電子紙的物理特性，因此不能一直放大縮小移動頁面閱讀。</li>
<li>想看其他的電子書格式，但是系統不支援。</li>
</ul>
<p>做了一些功課之後，我發現目前在 Kobo 系統上比較多人使用的就是 KOReader 跟 Plato 這兩套閱讀器，簡單整理成一張表格給有興趣嘗試的人參考。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="為何需要第三方閱讀軟體">為何需要第三方閱讀軟體</h4>
<p>Kobo 閱讀器內建的軟體在閱讀它們自家電子書的表現，其實已經很符合絕大多數人的需求了。但如果你有以下需求，就會想要尋找更強大的閱讀軟體：</p>
<ul>
<li>想放其他的電子書進去：如果那本電子書排版沒有設計得很好，加上內建的閱讀軟體可調整的選項不多，這樣讀起來就會有些痛苦。</li>
<li>想要閱讀 PDF 檔：很多 PDF 檔四周會留下不少空白，它又不能調整文字大小，甚至有的 PDF 是兩欄或三欄的排版，在十吋以下的螢幕閱讀會非常辛苦。由於電子紙的物理特性，因此不能一直放大縮小移動頁面閱讀。</li>
<li>想看其他的電子書格式，但是系統不支援。</li>
</ul>
<p>做了一些功課之後，我發現目前在 Kobo 系統上比較多人使用的就是 KOReader 跟 Plato 這兩套閱讀器，簡單整理成一張表格給有興趣嘗試的人參考。</p>
<!-- more -->
<h4 id="比較表">比較表</h4>
<table>
<thead>
<tr>
<th></th>
<th>KOReader</th>
<th>Plato</th>
</tr>
</thead>
<tbody>
<tr>
<td>網站</td>
<td><a href="https://github.com/koreader/koreader">https://github.com/koreader/koreader</a></td>
<td><a href="https://github.com/baskerville/plato">https://github.com/baskerville/plato</a></td>
</tr>
<tr>
<td>支援裝置</td>
<td>Cervantes, Kindle, Kobo, PocketBook, reMarkable, Android, Linux</td>
<td>Kobo</td>
</tr>
<tr>
<td>支援檔案</td>
<td>PDF, DjVu, CBT, CBZ, ePUB, FB2, Mobi, DOC, CHM, TXT</td>
<td>PDF, CBZ, FB2, XPS, ePUB, DjVu</td>
</tr>
<tr>
<td>介面</td>
<td>繁瑣、複雜</td>
<td>簡單、美觀</td>
</tr>
<tr>
<td>自訂性</td>
<td>除了一般的閱讀設定之外，還可以：<br />設定段落開頭縮排、上下左右不同邊距、字體的 kerning 與 hinting、自動偵測 PDF 可視範圍、PDF 轉文字重新排版、去除 PDF 浮水印。<br /><br />除此之外，還可以自訂進度條與狀態列，甚至還可以自訂多種不同手勢的動作。</td>
<td>一般的閱讀設定，像是：<br />調整字體與大小、調整邊距與行距、PDF 設定可視範圍、調整文字圖像對比度。</td>
</tr>
<tr>
<td>擴充性</td>
<td>支援 plugin 擴充其他功能，例如閱讀統計、雲端硬碟、Calibre 傳書、閱讀進度同步等等。</td>
<td>無法自行擴充，目前有計算機與素描板的功能。</td>
</tr>
<tr>
<td>缺點</td>
<td>不支援中文直排，不易上手，比較耗電</td>
<td>功能比較少，沒有中文化</td>
</tr>
<tr>
<td>備註</td>
<td>點擊畫面上方或下方顯示不同工具列，各個設定長按會跳出說明與設為預設值選項。</td>
<td>點擊畫面中間顯示工具列。</td>
</tr>
</tbody>
</table>
<h4 id="安裝方式">安裝方式</h4>
<p>這個安裝方式僅適用於 Kobo 閱讀器。</p>
<ol>
<li>將 Kobo 閱讀器連接到電腦，確認電腦有辨識到裝置。</li>
<li>到<a href="https://www.mobileread.com/forums/showpost.php?p=3797095&amp;postcount=1">這篇文章</a>的結尾下載你需要的 zip 檔，下載之後<strong>不需要</strong>解壓縮。</li>
<li>到<a href="https://www.mobileread.com/forums/showpost.php?p=3797096&amp;postcount=2">這篇文章</a>的結尾下載你的作業系統的自動安裝腳本，解壓縮之後跟剛才的 zip 檔放在一起。</li>
<li>執行安裝腳本並選擇要安裝的程式。</li>
<li>安裝完畢後，安全地退出 Kobo 裝置，如果它沒自動重開機，就手動重開。</li>
<li>重開之後，就會看到新的選單項目了。</li>
<li>更新方式就是以上步驟全部重做一遍，這樣最保險。</li>
<li>Kobo 系統升級之後，也需要重新安裝一遍。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[買了一台 Kobo 電子書閱讀器]]></title>
        <id>https://chiahsien.github.io/post/my-kobo-e-reader/</id>
        <link href="https://chiahsien.github.io/post/my-kobo-e-reader/">
        </link>
        <updated>2020-07-01T16:11:27.000Z</updated>
        <summary type="html"><![CDATA[<p>我是一個還蠻喜歡看書的人，實體書跟電子書也都有在買，之前就一直對電子書閱讀器感興趣，但因為早期電子紙的技術還不是很成熟所以沒有特別去關注。最近某一天，突然很想很想買一台電子書閱讀器，所以就開始 Google 各家閱讀器的特色與優缺點。</p>
<p>現在各家閱讀器都做得很不錯了，除非很倒霉買到機王，不然大部分的人應該都可以用得很開心。看過許多篇評比文章（例如<a href="https://twinsyang.net/archives/20998">這篇</a>），也爬過一些臉書社團（例如<a href="https://www.facebook.com/groups/ereadingclub/">這個</a>），最後總結出來挑選閱讀器的幾個要點，使用排除法大概就可以知道哪台閱讀器比較適合自己：</p>
]]></summary>
        <content type="html"><![CDATA[<p>我是一個還蠻喜歡看書的人，實體書跟電子書也都有在買，之前就一直對電子書閱讀器感興趣，但因為早期電子紙的技術還不是很成熟所以沒有特別去關注。最近某一天，突然很想很想買一台電子書閱讀器，所以就開始 Google 各家閱讀器的特色與優缺點。</p>
<p>現在各家閱讀器都做得很不錯了，除非很倒霉買到機王，不然大部分的人應該都可以用得很開心。看過許多篇評比文章（例如<a href="https://twinsyang.net/archives/20998">這篇</a>），也爬過一些臉書社團（例如<a href="https://www.facebook.com/groups/ereadingclub/">這個</a>），最後總結出來挑選閱讀器的幾個要點，使用排除法大概就可以知道哪台閱讀器比較適合自己：</p>
<!-- more -->
<ul>
<li>在哪買書看書：Amazon、Kobo、讀墨、Google Play、博客來、圖書館、其他</li>
<li>封閉式或開放式系統：通常封閉式系統比較穩定跟省電，開放式系統可以裝其他書店的 app</li>
<li>是否排斥 Android 系統</li>
<li>是否時常帶出門</li>
<li>是否常看 PDF 或漫畫</li>
<li>是否需要手寫筆記功能</li>
<li>是否需要彩色電子紙</li>
</ul>
<p>根據我自己的需求，</p>
<ul>
<li>我喜歡封閉式系統，又希望可以方便入手，所以就從 Amazon Kindle / Kobo / 讀墨 mooInk 這三家挑。</li>
<li>我主要看中文書，所以先把方便購買外文書為主的 Kindle 排除，剩下 Kobo 跟讀墨。</li>
<li>我不需要手寫，希望每天通勤都能帶出門，所以鎖定 8 吋以下的機型（不會比 iPad mini 大台）。</li>
<li>實際看過摸過用過之後，發現我不太喜歡 Android 系統。</li>
<li>我希望可以把電子書下載到電腦保存，日後如果換了閱讀器還可以繼續看。</li>
</ul>
<p>所以最後我選擇了 Kobo 的 <a href="https://www.rakuten.com.tw/shop/rakutenkobojapan/product/Libra/">Kobo Libra H2O</a>。它有實體翻頁鍵、7 吋的畫面、防水、待機時間夠久、整合 <a href="https://app.getpocket.com/">Pocket</a> 稍後閱讀服務、支援繁體中文。</p>
<p>用到目前很開心，也看了不少本書，推薦大家可以開始考慮電子書閱讀器了！如果對閱讀器感興趣，在台北的人可以去三創的三樓跟七樓看各家的實機。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iBeacon 的 Swift 開發筆記]]></title>
        <id>https://chiahsien.github.io/post/ibeacon-development-in-swift/</id>
        <link href="https://chiahsien.github.io/post/ibeacon-development-in-swift/">
        </link>
        <updated>2020-03-08T06:11:42.000Z</updated>
        <summary type="html"><![CDATA[<p>最近因為工作上的需求，需要透過 app 與支援 iBeacon 的裝置溝通，所以整理了一些筆記。在 iOS 的世界，app 可以作為 iBeacon 的接收者，也可以讓裝置作為 iBeacon 的發送者，這裡我只紀錄前者（接收者）的開發。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近因為工作上的需求，需要透過 app 與支援 iBeacon 的裝置溝通，所以整理了一些筆記。在 iOS 的世界，app 可以作為 iBeacon 的接收者，也可以讓裝置作為 iBeacon 的發送者，這裡我只紀錄前者（接收者）的開發。</p>
<!-- more -->
<h2 id="開發步驟">開發步驟</h2>
<h3 id="1-定位服務的設定">1. 定位服務的設定</h3>
<p>iBeacon 的接收需要使用到定位服務，所以首先需要做以下這些設定：</p>
<ol>
<li>加入 <code>CoreLocation.framework</code></li>
<li>在 <code>Info.plist</code> 加入 <code>NSLocationWhenInUseUsageDescription</code> key，如果需要在背景偵測是否有進入或離開 iBeacon 範圍，就要另外加入 <code>NSLocationAlwaysUsageDescription</code> key</li>
<li>在程式碼加入 <code>import CoreLocation</code></li>
</ol>
<h3 id="2-開始定位-ibeacon">2. 開始定位 iBeacon</h3>
<p>簡化起見，我們把程式碼放在 ViewController 裡頭，以下程式碼即可開始偵測 iBeacon。</p>
<pre><code class="language-swift">import CoreLocation

class ViewController: UIViewController {
    let locationManager = CLLocationManager()

    override func viewDidLoad() {
        super.viewDidLoad()

        locationManager.requestAlwaysAuthorization()
        locationManager.delegate = self

        let uuid = UUID(uuidString: &quot;12345678-1234-1234-1234-123456789ABC&quot;)!
        let region = CLBeaconRegion(proximityUUID: uuid, identifier: &quot;iBeacon Region&quot;)
        locationManager.startMonitoring(for: region)
    }
}
</code></pre>
<p>每個 iBeacon 裝置都會廣播三種資料用來作為裝置辨識，分別是 <code>UUID</code>、<code>major</code>、<code>minor</code>。舉個常見的場景：假設我是某店家，我可以把所有佈置的 iBeacon 裝置都設定同一組 <code>UUID</code>，然後設定不同的 <code>major</code> 代表這個裝置放在哪棟建築物，<code>minor</code> 代表這個裝置的編號。當我開發的 app 連上裝置後，就可以透過 <code>major</code> 跟 <code>minor</code> 得知目前的位置，藉此提供給使用者相關的資訊。</p>
<p>在上述的程式碼，我設定的 region 只有 <code>UUID</code>，代表符合這個 UUID 的裝置都可以被偵測。根據需求不同，也可以額外設定 <code>major</code> 或 <code>minor</code>。</p>
<p><code>locationManager</code> 呼叫 <code>startMonitoring(for:)</code> 就會開始偵測 iBeacon 裝置，然後把結果回報給 <code>delegate</code>，所以接下來我們要處理 delegate callbacks。</p>
<h3 id="3-處理-delegate-callbacks">3. 處理 delegate callbacks</h3>
<p>我們把 callbacks 放在 <code>extension ViewController: CLLocationManagerDelegate { }</code> 裡頭，首先來處理錯誤。</p>
<pre><code class="language-swift">func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
    print(&quot;Location manager did fail: \(error.localizedDescription)&quot;)
}
func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error) {
    print(&quot;Location manager monitoring did fail: \(error.localizedDescription)&quot;)
}
</code></pre>
<p>再來處理定位範圍。</p>
<pre><code class="language-swift">func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
    guard region is CLBeaconRegion else { return }
    // 在這裡做一些進入 region 的處理，例如提供一些提示
    guard CLLocationManager.isRangingAvailable() else { return }
    // 既然進入 region 了，那就偵測跟裝置的距離
    manager.startRangingBeacons(in: region as! CLBeaconRegion)
}

func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
    guard region is CLBeaconRegion else { return }
    // 在這裡做一些離開 region 的處理，例如提供一些提示
    guard CLLocationManager.isRangingAvailable() else { return }
    // 既然離開 region 了，那就停止偵測跟裝置的距離
    manager.stopRangingBeacons(in: region as! CLBeaconRegion)
}
</code></pre>
<p>上述兩個 callbacks 只有在進入跟離開範圍時，才會被呼叫。如果啟動 app 的時候已經在 iBeacon 裝置範圍內，則不會收到進入範圍的通知，所以我們需要額外的處理。</p>
<pre><code class="language-swift">func locationManager(_ manager: CLLocationManager, didStartMonitoringFor region: CLRegion) {
    // 開始偵測範圍之後，就先檢查目前的 state 是否在範圍內
    manager.requestState(for: region)
}

func locationManager(_ manager: CLLocationManager, didDetermineState state: CLRegionState, for region: CLRegion) {
    guard region is CLBeaconRegion else { return }

    if state == .inside { // 在範圍內
        if CLLocationManager.isRangingAvailable() {
            manager.startRangingBeacons(in: region as! CLBeaconRegion)
        }
    } else if state == .outside { // 在範圍外
        if CLLocationManager.isRangingAvailable() {
            manager.stopRangingBeacons(in: region as! CLBeaconRegion)
        }
    }
}
</code></pre>
<p>最後來處理定位距離。</p>
<pre><code class="language-swift">func locationManager(_ manager: CLLocationManager, rangingBeaconsDidFailFor region: CLBeaconRegion, withError error: Error) {
    print(&quot;Location manager ranging beacons did fail: \(error.localizedDescription)&quot;)
}

func locationManager(_ manager: CLLocationManager, didRangeBeacons beacons: [CLBeacon], in region: CLBeaconRegion) {
    // beacons 是一個 array，裡頭的 beacon 由近到遠排序
    if let beacon = beacons.first {
        // 取得距離最近的 beacon 了，作些事情吧
    }
}
</code></pre>
<h3 id="4-處理背景偵測">4. 處理背景偵測</h3>
<p>如果我們需要在沒有啟動 app 的時候，也能收到進入或離開 beacon 範圍的通知，那我們需要在 <code>AppDelegate</code> 做一些設定。</p>
<pre><code class="language-swift">import CoreLocation

class AppDelegate: UIResponder, UIApplicationDelegate {
    let locationManager = CLLocationManager()

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound]) { (granted, error) in
        }
        locationManager.delegate = self
        return true
    }
}

extension AppDelegate: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
        guard region is CLBeaconRegion else { return }

        let content = UNMutableNotificationContent()
        content.title = &quot;iBeacon Demo&quot;
        content.body = &quot;You enter a region&quot;
        content.sound = .default

        let request = UNNotificationRequest(identifier: &quot;Demo&quot;, content: content, trigger: nil)
        UNUserNotificationCenter.current().add(request, withCompletionHandler: nil)
    }

    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
        guard region is CLBeaconRegion else { return }

        let content = UNMutableNotificationContent()
        content.title = &quot;iBeacon Demo&quot;
        content.body = &quot;You exit a region&quot;
        content.sound = .default

        let request = UNNotificationRequest(identifier: &quot;Demo&quot;, content: content, trigger: nil)
        UNUserNotificationCenter.current().add(request, withCompletionHandler: nil)
    }
}
</code></pre>
<h2 id="注意事項">注意事項</h2>
<ul>
<li>需要實體機器開發 iBeacon app，Simulator 有諸多不便。</li>
<li>Beacon 是單向廣播，app 只能接收，不能跟 beacon 溝通。廣播的資料只有 <code>UUID</code>、<code>major</code>、<code>minor</code>，沒有其他資訊。app 收到這些資訊之後需要自行發揮創意，決定要做什麽事（例如可以打 API 跟 server 查詢這組 <code>major + minor</code> 代表什麼地點）。</li>
<li>UUID 的格式是 <code>12345678-1234-1234-1234-123456789ABC</code>，16進位字串，大小寫不拘。</li>
<li>最多只能 monitor 20 個 beacon，想要更多的話要自己手動管理。</li>
<li>記得要檢查 <code>isMonitoringAvailable(for:)</code> 跟 <code>isRangingAvailable()</code>。</li>
<li>只有在進入或離開 region 才會觸發通知，在 region 內任何的移動並不會造成持續一直接收通知。</li>
<li>要偵測 beacon，需要 <code>CoreLocation</code>，要作爲 beacon，需要 <code>CoreBluetooth</code>。</li>
<li>如果只是需要使用者位置，用 <code>NSLocationWhenInUseUsageDescription</code> key，呼叫 <code>requestWhenInUseAuthorization()</code>；如果需要在背景接收 notification，除了這個 key 還要加上 <code>NSLocationAlwaysUsageDescription</code> key，呼叫 <code>requestAlwaysAuthorization()</code></li>
<li>Monitoring 用來偵測是否在 beacon 範圍内；Ranging 用來判斷跟 beacon 的距離遠近。所以先用 monitor，在範圍内才啓動 ranging，ranging 很耗電，所以不要在背景做這件事。</li>
</ul>
<h2 id="參考資料">參考資料</h2>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/LocationAwarenessPG/RegionMonitoring/RegionMonitoring.html#//apple_ref/doc/uid/TP40009497-CH9-SW1">Region Monitoring and iBeacon</a></li>
<li><a href="https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf">Getting Started with iBeacon.pdf</a></li>
<li><a href="https://www.raywenderlich.com/632-ibeacon-tutorial-with-ios-and-swift">iBeacon Tutorial with iOS and Swift</a></li>
<li><a href="https://stackoverflow.max-everyday.com/2018/04/ios-ibeacon-tutorial/">iBeacon Tutorial</a></li>
<li><a href="https://medium.com/@jerrywang0420/ibeacon-%E6%95%99%E5%AD%B8-swift-3-ios-1d4ea88311be">iBeacon 教學</a></li>
<li><a href="https://github.com/rabschi/awesome-beacon">Awesome Beacon</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[必備的 Google Chrome Extension]]></title>
        <id>https://chiahsien.github.io/post/essential-google-chrome-extension/</id>
        <link href="https://chiahsien.github.io/post/essential-google-chrome-extension/">
        </link>
        <updated>2020-03-07T16:01:40.000Z</updated>
        <summary type="html"><![CDATA[<p>每次換工作都是一次整理工作環境的機會，我的 Google Chrome 也藉此重裝，雖然現在的工作跟以往完全不一樣，但我發現有些 extension 是不管在之前還是現在的工作、不管是公司還是家裏都會安裝的。以下就是我必備的七個 extension：</p>
]]></summary>
        <content type="html"><![CDATA[<p>每次換工作都是一次整理工作環境的機會，我的 Google Chrome 也藉此重裝，雖然現在的工作跟以往完全不一樣，但我發現有些 extension 是不管在之前還是現在的工作、不管是公司還是家裏都會安裝的。以下就是我必備的七個 extension：</p>
<!-- more -->
<ul>
<li>
<p><a href="https://chrome.google.com/webstore/detail/ublock/epcnnfbjfcgphgdmggkamkmgojdagdnn">uBlock</a><br>
這一定是我第一個安裝的套件，實在是因為現在的網頁充斥著大量的廣告，不裝擋廣告套件根本無法好好瀏覽網頁了。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/tab-group/gjgjkhbmehogehkdnoooeihkipifimme">Tab Group</a><br>
很容易為了查資料不知不覺就開啟幾十個分頁，由於只是臨時查詢的頁面，存為書籤感覺不太必要，一直開著又很浪費資源。這時我就會用這個套件把分頁存成不同的 group 方便日後參考，不需要的時候就把整個 group 砍掉。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/tabcopy/micdllihgoppmejpecmkilggmaagfdmb">TabCopy</a><br>
這個套件可以讓你自訂格式，複製目前開啟的分頁資訊，對於時常需要寫信寫文件的工程師來說很方便。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg">The Great Suspender</a><br>
可以自訂在什麼情況下，自動卸載分頁，對於會開啟很多分頁卻又沒有接電源的筆電而言是必需品。</p>
</li>
<li>
<p><a href="https://chrome.google.com/webstore/detail/autopagerize/igiofjhpmpihnifddepnpngfjhkfenbp">AutoPagerize</a><br>
顧名思義就是自動載入下一頁的套件，幫忙我們節省寶貴的時間。</p>
</li>
<li>
<p><a href="https://github.com/pd4d10/octohint">Octohint</a><br>
在 GitHub 跟 GitLab 網站加上 IntelliSense hint 的功能。</p>
</li>
<li>
<p><a href="https://www.octotree.io/">Octotree</a><br>
強化 GitHub 的瀏覽功能。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的 Mac 設定]]></title>
        <id>https://chiahsien.github.io/post/my-mac-setup/</id>
        <link href="https://chiahsien.github.io/post/my-mac-setup/">
        </link>
        <updated>2020-03-07T15:55:28.000Z</updated>
        <summary type="html"><![CDATA[<p>工程師都會有自己習慣的電腦設定，身為一個 iOS 開發者的我自然也不例外。本文記錄了我自己的環境建置，方便以後換電腦或換工作時可以快速 setup，也歡迎有需要的人拿去修改或留言推薦你喜歡的工具。</p>
]]></summary>
        <content type="html"><![CDATA[<p>工程師都會有自己習慣的電腦設定，身為一個 iOS 開發者的我自然也不例外。本文記錄了我自己的環境建置，方便以後換電腦或換工作時可以快速 setup，也歡迎有需要的人拿去修改或留言推薦你喜歡的工具。</p>
<!-- more -->
<h1 id="建立開發環境">建立開發環境</h1>
<p>最基本的開發環境大概就是以下這些，裝好就能開始 build code 了。</p>
<h3 id="xcode"><a href="https://apps.apple.com/tw/app/xcode/id497799835?mt=12">Xcode</a> 及其 Extension</h3>
<ul>
<li><a href="https://github.com/b-yng/Basics">Basic</a></li>
<li><a href="https://github.com/saildog/CodeGenerator">CodeGenerator</a></li>
<li><a href="https://apps.apple.com/tw/app/xcformat/id1165321484?mt=12">XCFormat</a></li>
<li><a href="https://github.com/theswiftdev/awesome-xcode-extensions">Awesome Xcode Extensions</a></li>
<li><a href="https://apps.apple.com/tw/story/id1380861178">App Store 上的合輯</a></li>
</ul>
<h3 id="homebrew"><a href="https://brew.sh">Homebrew</a></h3>
<pre><code class="language-bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<h3 id="git"><a href="https://git-scm.com">Git</a></h3>
<pre><code class="language-bash">brew install git
</code></pre>
<h3 id="rbenv-ruby">rbenv + ruby</h3>
<pre><code class="language-bash">brew install rbenv
rbenv install 2.4.1 # 沒特殊需求的話可以指定最新穩定版
rbenv rehash
rbenv global 2.4.1
</code></pre>
<p>在 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 檔案結尾加入以下設定，然後重新登入。</p>
<pre><code class="language-bash">export RBENV_ROOT=/usr/local/var/rbenv
if which rbenv &gt; /dev/null; then eval &quot;$(rbenv init -)&quot;; fi
</code></pre>
<h3 id="cocoapods"><a href="https://cocoapods.org/">CocoaPods</a></h3>
<pre><code class="language-bash">gem install cocoapods
pod setup
</code></pre>
<h1 id="必備工具軟體">必備工具軟體</h1>
<p>我的電腦裝的軟體不多，這邊列出的都是我比較常用的。</p>
<h3 id="瀏覽器">瀏覽器</h3>
<p>我常用的是 <a href="https://www.google.com.tw/chrome/browser/desktop/index.html">Google Chrome</a>，最近覺得 <a href="https://vivaldi.com/?lang=zh_TW">Vivaldi</a> 也蠻不錯的，兩個都符合我的需求：「多組帳號切換」、「設定可同步」、「套件多」。我不選擇 <a href="https://www.mozilla.org/zh-TW/firefox/new/">Firefox</a> 的原因是因為它的帳號切換不好用。</p>
<h3 id="通訊軟體">通訊軟體</h3>
<p>除了用 <a href="https://apps.apple.com/tw/app/line/id539883307?mt=12">LINE</a> 跟親友聯絡之外，工作上還需要用到 <a href="https://slack.com/downloads/osx">Slack</a> 跟 <a href="https://www.skype.com/zh-Hant/download-skype/skype-for-mac/">Skype</a>，有時還會用 <a href="https://telegram.org">Telegram</a> 跟 <a href="https://www.messenger.com">Facebook Messenger</a> 聊天打屁。</p>
<p>開一大堆視窗只為了傳訊息讓我覺得很蠢，所以我通常使用 <a href="https://meetfranz.com/">Franz</a> 這個整合型通訊工具，類似的還有 <a href="https://getstation.com">Station</a>。</p>
<h3 id="編輯器">編輯器</h3>
<p>我的文字跟程式碼編輯器首選是 <a href="https://code.visualstudio.com/">Visual Studio Code</a>，理由是它「速度夠快」、「界面友好」、「套件多」。之前我有用過 <a href="https://www.sublimetext.com/3">Sublime Text 3</a>，它真的很快，但因為它界面不夠友善而我懶得折騰所以放棄了。</p>
<p>工程師一定要用的還有 Markdown 編輯器，我強烈推薦 <a href="https://typora.io/">Typora</a>，它的所見即所得以及多種佈景主題讓我用過就再也離不開，後起之秀 <a href="https://marktext.app/">Mark Text</a> 也很令人讚賞。如果習慣傳統的左右兩欄界面的人，可以考慮用 <a href="https://macdown.uranusjr.com/">MacDown</a>。</p>
<h3 id="終端機">終端機</h3>
<p>內建的 Terminal 不夠好用，所以我都會改用 <a href="https://www.iterm2.com/">iTerm</a>，配合 <a href="http://ohmyz.sh/">oh-my-zsh</a> 使用 Zsh shell。</p>
<h3 id="開發工具">開發工具</h3>
<p>不管是工作的案子或是自己的 side project，我都會用 Git 做版本控制。Git 很強大但也很難用（雖然常用的指令就那麼幾個），還好它有很多免費或商用的 GUI，比較有名氣的大概是 <a href="https://www.sourcetreeapp.com/">SourceTree</a>、<a href="https://www.git-tower.com/mac/">Tower</a>、<a href="http://www.syntevo.com/smartgit/">SmartGit</a>、以及 <a href="https://www.gitkraken.com/git-client">GitKraken</a>。但我用的不是上述這些，我用的是 <a href="https://git-fork.com/">Fork</a>，它的使用介面非常友善，並且操作非常流暢。</p>
<p>我用 <a href="https://kapeli.com/dash">Dash</a> 觀看 API 文件與管理程式碼片段，用 <a href="https://www.getpostman.com/">Postman</a> 管理與呼叫 API。</p>
<p>如果要檢查 app 的 UI 的話，平時 Xcode 內建的工具就很夠用了，若需要進階一點可以考慮免費的 <a href="https://lookin.work">Lookin</a>，或是需要付費的 <a href="https://revealapp.com">Reveal</a> 或 <a href="https://sherlock.inspiredcode.io">Sherlock</a>。</p>
<h3 id="生產力工具">生產力工具</h3>
<p>為了支援更多的壓縮檔格式，我用 <a href="https://theunarchiver.com">The Unarchiver</a> 或 <a href="https://www.keka.io/">Keka</a> 解壓縮。如果不介意 command line 的話，也可以考慮 <a href="https://rar.tw/download.html">WinRAR for Mac</a>。</p>
<p>我會使用心智圖來紀錄一些比較發散或是比較階層性的想法，<a href="https://www.xmind.net">XMind</a> 是個很好用的工具，最大的缺點大概就是稍嫌笨重吧。</p>
<p>最近我也嘗試使用 <a href="https://joplinapp.org/">Joplin</a> 來作筆記，它支援 Markdown 格式，它也有 Web Clip 工具可以擷取網頁資料，用到目前還算不錯。</p>
<p>內建的 Spotlight 雖然不錯，但我更喜歡 <a href="https://www.alfredapp.com/">Alfred</a>，它的自訂性比較高。</p>
<p>我用 <a href="https://itunes.apple.com/tw/app/magnet/id441258766?mt=12">Magnet</a>（類似的免費替代品有 <a href="https://github.com/rxhanson/Rectangle">Rectangle</a>）跟 <a href="https://alt-tab-macos.netlify.app/">AltTab</a>（類似的免費替代品有 <a href="https://bahoom.com/hyperswitch">HyperSwitch</a>）強化 Mac 的視窗管理功能，用 <a href="https://github.com/Ji4n1ng/OpenInTerminal">Open In Terminal</a> 強化 Finder 的功能。如果覺得 Finder 真的太難用，可以考慮 <a href="https://www.binarynights.com/forklift/">ForkLift 3</a>，它除了是檔案總管之外，也是檔案傳輸工具。若是你只是需要多面板的 Finder，不需要檔案傳輸功能，可以考慮比較便宜的 <a href="https://apps.apple.com/tw/app/qspace/id1469774098?mt=12">QSpace</a>。</p>
<p>我用 <a href="https://apps.apple.com/tw/app/amphetamine/id937984704?mt=12">Amphetamine</a> 讓電腦不會自動休眠，某些時候（例如需要長時間執行程式或下載檔案）我會需要它。</p>
<p>我用 <a href="https://github.com/mangerlahn/Latest">Latest</a> 來一口氣檢查安裝的程式有沒有新版本，非常方便好用！</p>
<h1 id="線上工具">線上工具</h1>
<p>有些不常用的需求，可以使用一些免費的線上工具解決。</p>
<ul>
<li>
<p><a href="https://www.diffchecker.com/">Diff Checker</a></p>
<p>針對兩份文字做 diff 的工具，為什麼 VSCode 沒有套件可以讓我左右兩邊各貼一段文字然後就自動 diff 呢？</p>
</li>
<li>
<p><a href="https://jsoneditoronline.org/">JSON Editor Online</a></p>
<p>檢視與編輯 JSON 的工具</p>
</li>
<li>
<p><a href="https://www.draw.io/">draw.io</a>、<a href="https://www.zenflowchart.com/">Zen Flowchart</a></p>
<p>流程圖與其他圖表繪製工具</p>
</li>
<li>
<p><a href="http://asciiflow.com/">ASCIIFlow Infinity</a></p>
<p>輕鬆畫出 ASCII 圖，我拿來畫程式架構，然後放在程式碼註解裡。</p>
</li>
<li>
<p><a href="https://www.befunky.com/features/collage-maker/">Collage Maker</a></p>
<p>圖片拼貼工具，通常我在送 PR 給同事 review 時，如果是關於 UI 的修改，我會附上前後對照圖。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iPlayground 2019 的影片上線啦]]></title>
        <id>https://chiahsien.github.io/post/iplayground-2019-video/</id>
        <link href="https://chiahsien.github.io/post/iplayground-2019-video/">
        </link>
        <updated>2019-11-27T14:19:07.000Z</updated>
        <content type="html"><![CDATA[<p>期待已久的 iPlayground 2019 的影片終於弄好上線啦，感謝工作人員的辛勞！<a href="https://www.youtube.com/watch?v=7ZkE7fyd20g&amp;list=PLJN8Q2M8xECkvIbNFM30Bu91qbN92SXND">趕緊去瞧瞧</a>!</p>
<p>這是我講的「漫談 iOS 架構：MVC / MVVM / VIPER 與 Redux」，搭配<a href="../../post/common-ios-architecture-from-mvc-to-viper-with-redux">之前的文章</a>觀看會更清楚。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/qDyb6AkX0s0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漫談 iOS 架構：從 MVC 到 VIPER，以及 Redux]]></title>
        <id>https://chiahsien.github.io/post/common-ios-architecture-from-mvc-to-viper-with-redux/</id>
        <link href="https://chiahsien.github.io/post/common-ios-architecture-from-mvc-to-viper-with-redux/">
        </link>
        <updated>2019-09-21T15:30:06.000Z</updated>
        <summary type="html"><![CDATA[<p>很榮幸我能在今年的 <a href="https://iplayground.io/2019/">iPlayground</a> 分享了過去幾年以來，我對於 iOS 架構的一些看法與心得，<a href="https://speakerdeck.com/chiahsien/common-ios-architectures-from-mvc-to-viper-with-redux">投影片由此下載</a>，本文則是比較詳細的文字稿。</p>
<p>這幾年大家逐漸重視 iOS 的架構設計，從最基本的 MVC 到開始普及的 MVP / MVVM，到分工細膩的 VIPER，每個 pattern 都有擁護者；近期也有為了解決畫面轉換的 Router / Coordinator 以及為了解決資料一致性的 Redux。</p>
<p>我們 app 早期的架構是 MVC，後來改成 MVVM，後來為了因應複雜的流程所以引進 Coordinator，也引進 Redux 處理資料一致性的問題。</p>
<p>接下來會聊聊這幾種 pattern 及其演化過程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很榮幸我能在今年的 <a href="https://iplayground.io/2019/">iPlayground</a> 分享了過去幾年以來，我對於 iOS 架構的一些看法與心得，<a href="https://speakerdeck.com/chiahsien/common-ios-architectures-from-mvc-to-viper-with-redux">投影片由此下載</a>，本文則是比較詳細的文字稿。</p>
<p>這幾年大家逐漸重視 iOS 的架構設計，從最基本的 MVC 到開始普及的 MVP / MVVM，到分工細膩的 VIPER，每個 pattern 都有擁護者；近期也有為了解決畫面轉換的 Router / Coordinator 以及為了解決資料一致性的 Redux。</p>
<p>我們 app 早期的架構是 MVC，後來改成 MVVM，後來為了因應複雜的流程所以引進 Coordinator，也引進 Redux 處理資料一致性的問題。</p>
<p>接下來會聊聊這幾種 pattern 及其演化過程。</p>
<!-- more -->
<h2 id="mvc">MVC</h2>
<figure data-type="image" tabindex="1"><img src="https://chiahsien.github.io/post-images/1569079938840.png" alt="MVC" loading="lazy"></figure>
<p>這是 Apple 的 MVC 架構（跟原始的 MVC 架構有些許不同，但這不重要），各自負責的職責如下所述：</p>
<ul>
<li><strong>Model</strong>：負責處理資料相關事務（計算、修改、存取等等），並通知 Controller 資料的變化，所以這裡的 model 不是單純的 data model 而是所謂的 fat model。</li>
<li><strong>View</strong>：負責顯示各種畫面元件，並在使用者執行動作（滑動、點擊、按壓等等）時通知 Controller。</li>
<li><strong>Controller</strong>：負責在使用者有動作的時候去執行特定工作、要求 Model 更新狀態、在 Model 有變化時更新 View 的內容來顯示這些變化。</li>
</ul>
<p>一切看來都很美好，直到我們的 app 變得稍微複雜。在現實環境中，我們的 Controller 承擔的責任不只這些，還需要負責其他事情：</p>
<ul>
<li>如果不是用 storyboard / xib，那就需要建立與擺放各個 views；就算是用 storyboard / xib，也可能需要透過程式碼調整一些設定。</li>
<li>執行各種動畫。</li>
<li>轉換資料以便讓各個 views 顯示。</li>
<li>管理整個頁面的 state 變化。</li>
<li>作為其他元件的 data sources 與 delegates。</li>
<li>執行 API call 或 database access。</li>
<li>present / dismiss 或 push / pop 其他的 view controllers</li>
<li>其他有的沒的。。。</li>
</ul>
<p>通常這個時候 Controller 的程式碼已經破千行，到達一個難以管理、不想面對的狀態，這也是 MVC 被戲稱為 <strong>Massive View Controller</strong> 的原因。一個有經驗的工程師在這種情況下自然而然會想要 refactor，讓每個元件負責的事情簡化一點，因此就演化出接下來的 <strong>MVP</strong> 與 <strong>MVVM</strong> 架構。</p>
<h2 id="mvp-與-mvvm">MVP 與 MVVM</h2>
<p>在實際的開發中，我們會發現 View 跟 View Controller 的生命週期通常是一致的，並且它們的關係密不可分，所以我們可以把 View 跟 View Controller 視為一體，都稱作 <strong>View</strong>。顧名思義 View Controller 應該只負責跟處理畫面有關的事務，所以在 refactor 的過程就會自然的把「跟處理畫面無關」的程式碼（像是 API call、database access、把 raw data 轉成適合顯示的 data）抽出來交給另一個物件負責，這個物件在 MVP 叫做 <strong>Presenter</strong>，在 MVVM 叫做 <strong>View Model</strong>。</p>
<figure data-type="image" tabindex="2"><img src="https://chiahsien.github.io/post-images/1569079981221.png" alt="MVP" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chiahsien.github.io/post-images/1569079993405.png" alt="MVVM" loading="lazy"></figure>
<p>以上兩張分別是 MVP 與 MVVM 的架構圖，明顯看得出來兩者幾乎一模一樣，除了 Presenter 跟 View Model 的命名不同之外，最大的差異在於 View 跟 Presenter / View Model 的互動方式。</p>
<p><strong>MVP</strong></p>
<ul>
<li>在使用者動作發生時，View 要求 Presenter 做事。</li>
<li>Presenter 做完事之後，通知 View 更新畫面，透過 <code>delegate</code> 是最常見的做法。</li>
</ul>
<p><strong>MVVM</strong></p>
<ul>
<li>強調 binding，常見的 binding framework 有 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>、<a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>、或是 Apple 在 iOS 13 推出的 <a href="https://developer.apple.com/documentation/combine">Combine</a>。</li>
<li>將使用者動作綁定到 View Model 的某個 method。</li>
<li>將 View Model 的 property 變化綁定到 View 的畫面更新。</li>
</ul>
<p>你會發現它們做的事情是一模一樣的，所謂的 <code>binding</code> 說穿了就是幫這些基本操作（<code>delegate</code>, <code>target-action</code>, <code>KVO</code>）裹上一層糖衣，讓程式碼變得更加容易維護。</p>
<p>所以 MVP 跟 MVVM 是一樣的東西，但實作細節則是有些不同。一般來說我們應該視複雜度及團隊成員能力來決定要用 MVP 還是 MVVM，甚至同時混用也是有可能。</p>
<h2 id="coordinator">Coordinator</h2>
<p>身為 iOS 開發者，我們早就習慣在 View Controller 裡頭去建立並透過 <code>present / push</code> 的方式呈現另一個 View Controller，也很習慣在 View Controller 按了一個按鈕之後就把自己 <code>dismiss / pop</code>，更別說我們會在 View Controller 裡頭建立與設定 <code>UINavigationItem</code>。這樣的 View Controller 會有以下的問題：</p>
<ul>
<li><strong>難以重複使用</strong>：因為把呈現方式寫死了，所以很難在不同場景使用。</li>
<li><strong>流程缺乏彈性</strong>：因為把下一個畫面寫死了，所以很難調整畫面流程。</li>
<li><strong>知道太多</strong>：View Controller 應該專注於自身的畫面，不應該插手別的畫面。</li>
<li><strong>不合理</strong>：View Controller 不應該知道自己會被包在 Navigation 或 Tabbar Controller 裡頭，更別說知道自己會被 present 或 push 到螢幕上。</li>
</ul>
<p>所以一個理想的 View Controller 會專心負責一個畫面，甚至只負責畫面的某個區域，有另一個綜觀全局的管理者負責組合、調度這些 View Controllers。這個角色就是 <strong>Coordinator</strong>，它的功能如下：</p>
<ul>
<li>負責<strong>建立與切換</strong> View Controllers。</li>
<li>負責組合出<strong>一個畫面(Scene)<strong>或</strong>一套流程(Scenario)</strong>。</li>
<li>負責組合多個 <strong>child coordinators</strong>。</li>
</ul>
<blockquote>
<p>廣義來看，一個 Container View Controller 正是承擔了 Coordinator 的職責。</p>
</blockquote>
<p>因此一個 Coordinator 通常就是一組 feature 或是一個 module 的入口，我們可以透過這種方式靈活的組合出一個 app。Coordinator 可以套用在各種架構 (MVC / MVVM / VIPER) 與畫面實作 (code / storyboard / xib)；至於實作細節我推薦要繼承自 <code>UIViewController</code>（為何不繼承自 <code>NSObject</code> 或單純的 <code>class</code>，原因可參考<a href="https://www.appcoda.com.tw/coordinator/">這篇</a>與<a href="https://github.com/onmyway133/blog/issues/106">這篇</a>文章）。</p>
<p>我們把 MVVM 搭配 Coordinator 的架構稱為 <strong>MVVM-C</strong>，由 View Controller 或 View Model 負責跟 Coordinator 溝通。我個人傾向於讓 <strong>View Controller</strong> 負責溝通，因為 View Controller 是管理畫面的人，它最清楚當前畫面是否已經顯示完畢，也代表它最清楚溝通的時機點。</p>
<blockquote>
<p>常見的溝通方法有兩種：</p>
<ul>
<li>Coordinator 是 View Controller 的 delegate，VC 通知 delegate 目前的畫面狀態</li>
<li>View Controller weak reference 到 Coordinator，VC 根據目前的畫面狀態要求 Coordinator 做事</li>
</ul>
<p>兩者做法一樣但意義不同，我認為前者才是合理的。</p>
</blockquote>
<h2 id="common-codes">Common Codes</h2>
<p>到目前為止我們把畫面轉換的邏輯搬到 <strong>Coordinator</strong>，把業務邏輯搬到 <strong>View Model</strong>，View Controller 精簡到只剩下單一畫面的管理，再也不是動輒破千行的怪物（根據經驗此時的 View Controller 大概不到五百行，就算不用 storyboard / xib 建立畫面，程式碼也不到八百行）。</p>
<p>尷尬的是，由於業務邏輯通常程式碼都不少，所以在 View Controller 瘦身的同時，View Model 卻開始變得臃腫；更糟糕的是，可能有很多重複的業務邏輯散落在多個 View Model 裡頭。身為一個工程師，我們自然而然會想要把這些重複的部分抽出來。</p>
<p>這些被抽出來的部分，我們通常會命名為 <code>Manager</code> / <code>Service</code> / <code>Helper</code> / <code>Utility</code>，它們會直接或間接存取 data model。如此一來，業務邏輯可被多人共用，View Model 也不再那麼龐大，只需要專注在調用業務邏輯與轉換資料格式即可。</p>
<blockquote>
<p>再次提醒：這裡提到的 View Model 跟 Presenter 是一樣的東西。</p>
</blockquote>
<h2 id="viper">VIPER</h2>
<p>或許你有聽過或看過 VIPER 的介紹，然後就覺得它的名詞一大堆好複雜、檔案一大堆好麻煩，甚至還有人準備了給 Xcode 用的 VIPER New File Template，想到就覺得頭大、難以推廣，乾脆直接放棄，對吧？</p>
<p>如果我告訴你，其實你已經會用 VIPER 了呢？</p>
<figure data-type="image" tabindex="4"><img src="https://chiahsien.github.io/post-images/1569080028925.png" alt="VIPER" loading="lazy"></figure>
<p>這是 VIPER 的架構圖，有沒有覺得很眼熟？</p>
<ul>
<li><strong>View</strong>：就是 MVVM / MVP 的 View</li>
<li><strong>Presenter</strong>：就是 MVP 的 Presenter，也是 MVVM 的 View Model</li>
<li><strong>Router</strong>（也有人稱為 <strong>Wireframe</strong>）：就是 Coordinator</li>
<li><strong>Interactor</strong>：就是那些可共用或不可共用的 Manager / Service / Helper / Utility</li>
<li><strong>Entity</strong>：就是單純的 data model</li>
</ul>
<p>說到這裡相信你已經理解，MVC / MVVM / VIPER 其實是同一件事，它們只是工程師在 refactor 過程針對不同程式碼複雜度的規劃罷了。</p>
<blockquote>
<p>附帶一提：我傾向由 View Controller 跟 Router 溝通，而不是圖中的 Presenter。</p>
</blockquote>
<h2 id="redux">Redux</h2>
<p>行文至此，不知道你有沒有發現這些模式其實是「<strong>UI 架構</strong>」：它們假設你有一套辦法去存取或修改資料，然後它們提供的方案是<strong>關於如何處理「界面顯示 / 使用者互動 / 資料存取」之間的關係</strong>。</p>
<p>當程式越長越大，要儲存的狀態越來越多，不同畫面之間需要同步的資料也越來越多，我們該如何管理資料的存取、確保其一致性與正確性呢？我們可以從前端的 Redux 架構得到啟發，其重點在於「<strong>資料的流動是單向的，只有一份資料，並且只有一個角色可以修改資料</strong>」。</p>
<figure data-type="image" tabindex="5"><img src="https://chiahsien.github.io/post-images/1569080043778.jpg" alt="Redux" loading="lazy"></figure>
<p>從上圖可以看到，Redux 架構很簡單，只有四個角色：</p>
<p><strong>Action</strong></p>
<ul>
<li>單純的資料結構，沒有任何業務邏輯。</li>
<li>用來表示某個動作，並附帶這個動作所需的資料。</li>
</ul>
<p><strong>Store</strong></p>
<ul>
<li>Redux 架構的中心。</li>
<li>負責持有 Reducers。</li>
<li>負責持有 State，並讓外界可以取得目前的 State。</li>
<li>負責收到 Action，把 Action 跟目前的 State 傳給 Reducers。</li>
<li>負責送出「State 已經更新」的通知給感興趣的人。</li>
</ul>
<blockquote>
<p>送出 Action 到收到 State 變化之間是**「async」**的。</p>
</blockquote>
<p><strong>State</strong></p>
<ul>
<li>單純的資料結構。</li>
<li>代表整個 app 需要共享的所有資料。</li>
<li><a href="https://hackernoon.com/shape-your-redux-store-like-your-database-98faa4754fd5">像設計資料庫一樣設計你的 State</a>，至少做到<a href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape">一階正規化</a>。</li>
</ul>
<blockquote>
<p>雖然還沒實驗過，我覺得在龐大複雜的環境，直接用資料庫實作 State 應該是可行的。</p>
</blockquote>
<p><strong>Reducer</strong></p>
<ul>
<li>輸入是「Action」跟「State」，輸出是「<strong>修改過</strong>的 State」。</li>
<li><strong>理論上</strong>是 <strong>pure function</strong>，實際上為了效能考量，我們直接修改 State。</li>
</ul>
<blockquote>
<p>Reducers 之間不要有相依性，不要假設它們執行的先後次序。</p>
</blockquote>
<h2 id="完整流程">完整流程</h2>
<p>要怎麼把 UI 架構跟 Redux 結合起來呢？你已經知道 MVC / MVP / MVVM / VIPER 是一樣的東西，以 VIPER 為例，完整流程如下：</p>
<ol>
<li>使用者執行某項操作，View 呼叫 Presenter 對應的函式。</li>
<li>Presenter 呼叫 Interactor 對應的函式。</li>
<li>Interactor 送出對應的 Action 與附加資訊給 Store。</li>
<li>Store 把 Action 丟給 Reducers，認得這個 Action 的 Reducers 就會去修改 State。</li>
<li>修改完畢後，Store 送出通知讓其他人知道 State 有變化。</li>
<li>Interactor 收到通知後，跟 Store 取得最新的 State 裡頭感興趣的 data 傳給 Presenter。</li>
<li>Presenter 通知 View 資料有變化，View 更新對應的 UI。</li>
</ol>
<blockquote>
<p>補充說明：</p>
<p>在 Redux 原始設計裡頭，有個東西叫做 <code>Middleware</code> 作為 <code>Action</code> 的擴充，它用來處理一些 <strong>async</strong> 的 Action（例如 API call）或是一些 <strong>side effect</strong>（像是 logging 或 event tracking）。但我覺得這樣的設計對 iOS 開發來說太複雜並且不直覺，所以我沒有照搬這套作法，我的作法是：</p>
<ol>
<li>API call / Logging / Event tracking 這些工作交給 Interactor / Service / Manager 等角色處理，<strong>處理完畢再送 Action</strong>。</li>
<li>Action 單純代表要對 State 做的操作就好。</li>
</ol>
</blockquote>
<p>附帶一提，你需要在資料有變化的時候更新對應的 UI，如果是在 <code>UITableView / UICollectionView</code> 的場景，你可以考慮借助 <a href="https://github.com/Instagram/IGListKit">IGListKit</a> 的 diff 功能或是 <a href="https://github.com/onmyway133/DeepDiff">DeepDiff</a>，如果是 iOS 13 則可以使用 <a href="https://developer.apple.com/videos/play/wwdc2019/220/">Diffable Data Source</a> 得知哪些資料變了。</p>
<h2 id="寫在最後">寫在最後</h2>
<p>我們大略的介紹了幾個 iOS 最常見的架構，講白了就是一連串的 refactor 過程，從 View Controller 開始逐步 refactor 到其他元件。除了上述這些之外，或許你還有聽過 <a href="https://clean-swift.com/clean-swift-ios-architecture/">VIP</a> 或 Uber 的 <a href="https://github.com/uber/RIBs">RIBs</a>，相信你現在再去看這些架構，會有一些不同的想法。</p>
<p>有鑑於現在的 app 大多有好幾個複雜頁面，我推薦採用 <strong>MVVM-C</strong> 架構，視情況將元件拆成更小的元件；再搭配 <strong>Composition</strong> 的概念將多個 View Controller 組合成一個大的 View Controller，或是將多個 Coordinator 組合成一個大 Coordinator。</p>
<p>如果你的 app 真的很難以 refactor，或是其他現實因素讓你無法套用這些 pattern，我建議至少試試看 <strong>Coordinator</strong>，它的技術門檻相對低、需要的改動少、效果也很好，很值得一試！</p>
<p>我們的目標就是要合理劃分各個元件的職責，讓每個元件不要太龐大，並且讓同事以及未來的自己有能力繼續維護程式碼。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用 CoreML 來判別圖片]]></title>
        <id>https://chiahsien.github.io/post/detect-images-by-coreml/</id>
        <link href="https://chiahsien.github.io/post/detect-images-by-coreml/">
        </link>
        <updated>2019-04-22T16:02:15.000Z</updated>
        <summary type="html"><![CDATA[<p>在 WWDC 2018 蘋果推出了 <a href="https://developer.apple.com/documentation/createml">Create ML</a> ，讓開發者可以輕鬆的建立並訓練適合自己需求的機器學習模型，它支援圖片、自然語言、表格資料的學習。最近這幾天我就想到要訓練一個自家的模型，用來檢查使用者是否打算上傳不恰當的圖片。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在 WWDC 2018 蘋果推出了 <a href="https://developer.apple.com/documentation/createml">Create ML</a> ，讓開發者可以輕鬆的建立並訓練適合自己需求的機器學習模型，它支援圖片、自然語言、表格資料的學習。最近這幾天我就想到要訓練一個自家的模型，用來檢查使用者是否打算上傳不恰當的圖片。</p>
<!-- more -->
<h1 id="訓練自己的模型">訓練自己的模型</h1>
<p>首先要準備好訓練資料，將資料分類放在不同的資料夾，不同的資料夾名稱就是所謂的 <code>Label</code>。舉例來說我會建立一個 <code>Unsafe</code> 資料夾存放腥羶色的圖片，再建立一個 <code>Safe</code> 資料夾存放正常的圖片。這裡有一些要注意的地方：</p>
<ul>
<li>每個資料夾裡頭的檔案個數至少要有 <strong>10</strong> 個。</li>
<li>每個資料夾裡頭的檔案個數不要相差太多。</li>
<li>每個資料夾裡頭的檔案個數越多越好。</li>
</ul>
<p>再來我們要建立一個新的 playground，選擇 <code>macOS -&gt; Blank</code> template（注意：要選 <code>macOS</code> 不是 <code>iOS</code>），然後把內容改成以下程式碼：</p>
<pre><code class="language-Swift">import CreateMLUI

let builder = MLImageClassifierBuilder()
builder.showInLiveView()
</code></pre>
<p>在 Xcode 裡頭切換到 <code>Assistant Editor</code> 並執行 playground，就能在 Assistant Editor 看到 <code>Live View</code> 了。把我們事先準備好的訓練資料拉進 Live View，它就會開始建立並訓練模型。</p>
<p>訓練好之後，我們可以把一些測試資料拉進 Live View，看看這個模型的判斷是否準確，如果滿意的話就可以把模型存起來了。</p>
<h1 id="利用模型判斷資料">利用模型判斷資料</h1>
<p>假設我們把模型存成 <code>ImageClassifier.mlmodel</code>，接下來就是把它拉進 Xcode Project 裡頭。再來我們要建立一個 <code>ImageDetector</code> class，負責把圖片餵給模型，並回傳模型判斷的結果。這個 class 只有一個 method，讓使用者傳一張圖片進來判斷，判斷成功的話會回應信心值（0~1），失敗的話回應一個 Error。</p>
<pre><code class="language-objc">@interface ImageDetector : NSObject

- (void)checkImage:(UIImage *)image withSuccess:(void (^)(float confidence))success failure:(void (^)(NSError *error))failure;

@end
</code></pre>
<p>實作也很簡單，首先要 import 必要的檔案，<code>ImageClassifier.h</code> 是我們把 <code>ImageClassifer.mlmodel</code> 拉進 project 的時候自動產生的：</p>
<pre><code class="language-objc">#import &quot;ImageDetector.h&quot;
#import &quot;ImageClassifier.h&quot;

@import CoreML;
@import Vision;

@interface ImageDetector ()
@property (nonatomic, strong) VNCoreMLModel *model;
@end
</code></pre>
<p>我們在 <code>init</code> 的時候載入模型：</p>
<pre><code class="language-objc">- (instancetype)init {
    if (self = [super init]) {
        ImageClassifier *classifier = [[ImageClassifier alloc] init];
        _model = [VNCoreMLModel modelForMLModel:classifier.model error:NULL];
    }
    return self;
}
</code></pre>
<p>然後實作唯一的 public method：</p>
<pre><code class="language-objc">- (void)checkImage:(UIImage *)image withSuccess:(void (^)(float confidence))success failure:(void (^)(NSError *error))failure {
    VNImageRequestHandler *handler = nil;
    if (image.CGImage) {
        handler = [[VNImageRequestHandler alloc] initWithCGImage:image.CGImage options:@{}];
    } else if (image.CIImage) {
        handler = [[VNImageRequestHandler alloc] initWithCIImage:image.CIImage options:@{}];
    }
    [self checkWithRequestHandler:handler success:success failure:failure];
}
</code></pre>
<p>最後實作唯一的 private method：</p>
<pre><code class="language-objc">- (void)checkWithRequestHandler:(nullable VNImageRequestHandler *)handler success:(void (^)(float confidence))success failure:(void (^)(NSError *error))failure {
    if (!handler) {
        NSError *error = [NSError errorWithDomain:@&quot;com.imageDetector&quot; code:0 userInfo:nil];
        failure(error);
        return;
    }

    // 建立一個 request，用來判斷圖片並處理判斷的結果
    VNCoreMLRequest *req = [[VNCoreMLRequest alloc] initWithModel:self.model completionHandler:^(VNRequest * _Nonnull request, NSError * _Nullable error) {
        if (error) {
            failure(error);
            return;
        }

        NSString *label = @&quot;UnSafe&quot;; // 這個就是你要的 Label，也就是訓練資料的資料夾名稱
        NSArray&lt;VNClassificationObservation *&gt; *observations = request.results;
        for (VNClassificationObservation *observation in observations) {
            if (![observation.identifier isEqualToString:label]) {
                continue;
            }
            success(observation.confidence);
            return;
        }

        NSError *e = [NSError errorWithDomain:@&quot;com.imageDetector&quot; code:0 userInfo:nil];
        failure(e);
    }];
    req.preferBackgroundProcessing = YES;

    // 丟到 background queue 執行，才不會卡住 UI
    dispatch_async(dispatch_get_global_queue(QOS_CLASS_UTILITY, 0), ^{
        NSError *error = nil;
        if (![handler performRequests:@[req] error:&amp;error]) {
            failure(error);
        }
    });
}
</code></pre>
<p>要注意的是，呼叫者如果要在 <code>success / failure</code> callback 處理畫面更新，記得要切回 <code>main queue</code>。</p>
<h1 id="參考資料">參考資料</h1>
<p>至此，一個為你量身定制的機器學習模型就可以正常運作了，而且 iOS 11 也有支援喔。如果有興趣的話，也可以接著看看更多的參考資料。</p>
<ul>
<li><a href="https://www.raywenderlich.com/5653-create-ml-tutorial-getting-started">Create ML Tutorial: Getting Started | raywenderlich.com</a></li>
<li><a href="https://www.appcoda.com/create-ml/">Create ML: How to Train Your Own Machine Learning Model in Xcode 10</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/703/">WWDC 2018, Section 703 - Introducing Create ML</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/712">WWDC 2018, Section 712 - A Guide to Turi Create</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/717">WWDC 2018, Section 717 - Vision with Core ML</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用 Appium 測試 iOS App]]></title>
        <id>https://chiahsien.github.io/post/how-to-use-appium-to-test-ios-app/</id>
        <link href="https://chiahsien.github.io/post/how-to-use-appium-to-test-ios-app/">
        </link>
        <updated>2019-04-09T02:24:09.000Z</updated>
        <summary type="html"><![CDATA[<p>前一陣子我們開始嘗試 UI 自動化測試，我們首先嘗試 Appium，藉此機會幫安裝過程做個記錄。</p>
]]></summary>
        <content type="html"><![CDATA[<p>前一陣子我們開始嘗試 UI 自動化測試，我們首先嘗試 Appium，藉此機會幫安裝過程做個記錄。</p>
<!-- more -->
<h3 id="appium-簡介">Appium 簡介</h3>
<p><a href="http://appium.io">Appium</a> 是一套開放原始碼的自動化測試框架，它支援 native / hybrid / mobile web apps。它走的是 <code>Client-Server</code> 架構，透過 <code>REST API</code> 與特定的 JSON protocol 進行溝通。</p>
<h4 id="server">Server</h4>
<p>Appium 說穿了就是個 HTTP Server，它使用 Node.js 開發，可以運行在本機端或遠端。它透過個別的 <code>driver</code> 跟不同的平台互動（iOS / Android / Windows / Mobile web / etc）。當它收到 client 請求，便會啟動 driver 跟模擬器或實機上的 app 溝通，取得特定資訊之後回傳給 client。</p>
<h4 id="client">Client</h4>
<p>Client 指的是 web drivers，目前官方提供 <code>Ruby / Python / Java / JavaScript (Node.js) / PHP / C# (.Net) / RobotFramework</code> 等程式語言開發的 web drivers。除此之外你可以選擇其他熟悉的語言開發，只要開發出來的東西符合 <code>Selenium WebDriver(JSON Wire) Protocol + Mobile JSON Wire Protocol</code> 即可。你高興的話，要使用 <code>cURL</code> 也可以。</p>
<h4 id="常見測試流程">常見測試流程</h4>
<ol>
<li>啟動 Server</li>
<li>建立 Client</li>
<li>Client 跟 Server 要求建立特定的模擬器或實機的 session</li>
<li>Client 送出指令（滑動 / 點擊 / 鍵盤輸入等等）</li>
<li>Client 預期在一段時間內，app UI 會有預期的變化</li>
</ol>
<h3 id="如何安裝">如何安裝</h3>
<p>以在 macOS Mojave 測試 iOS app 為例，說明如何安裝 Appium Client + Server。</p>
<h4 id="server-2">Server</h4>
<p>最簡單的方法就是下載 <a href="https://github.com/appium/appium-desktop/releases/latest">Appium Desktop</a>，它裡頭包含了 Server 跟各種 Drivers。如果你有特殊需求，可以使用 <a href="http://appium.io/docs/en/about-appium/getting-started/?lang=zh#installation-via-npm">npm 手動安裝</a>。</p>
<h4 id="client-2">Client</h4>
<p>我們會透過 <a href="https://brew.sh">Homebrew</a> 安裝需要的工具，如果還沒有安裝 Homebrew 的話，可以在 Terminal 輸入以下指令安裝。</p>
<pre><code class="language-bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<p>你可以選擇喜歡的程式語言開發測試程式，這裡我使用 Python。以下指令會同時安裝 <code>Python 3</code> 跟 <code>pip3</code>。</p>
<pre><code class="language-bash">brew install python3
</code></pre>
<p>使用以下指令安裝 Appium Python Client 跟相關檔案。</p>
<pre><code class="language-bash">pip3 install Appium-Python-Client
pip3 install -U pytest
</code></pre>
<p>測試 iOS app 還需要 <a href="https://github.com/Carthage/Carthage">Carthage</a>，才能執行 <code>WebDriverAgent</code>。</p>
<pre><code class="language-bash">brew install carthage
</code></pre>
<p>最後，為了設定模擬器的各種 permissions，不讓它跳出確認對話框來煩我們，我們還需要安裝 <a href="https://github.com/wix/AppleSimulatorUtils">AppleSimulatorUtils</a>。</p>
<pre><code class="language-bash">brew tap wix/brew
brew install wix/brew/applesimutils
</code></pre>
<h3 id="如何打包測試-app">如何打包測試 APP</h3>
<p>這裡是以模擬器為例，如果要在實機測試，可以參考<a href="http://appium.io/docs/en/drivers/ios-xcuitest-real-devices/">這個連結</a>，如果要包其他平台，可以參考<a href="http://appium.io/docs/en/writing-running-appium/running-tests/">這個連結</a>。首先我們要用模擬器的 SDK build 一個可以在模擬器運行的 app。</p>
<pre><code class="language-bash">xcodebuild -showsdks
</code></pre>
<p>這個指令會列出所有安裝的 SDK，看起來像這樣，你的畫面可能跟我的會不太一樣。</p>
<pre><code>➜  ~ xcodebuild -showsdks
iOS SDKs:
	iOS 12.1                      	-sdk iphoneos12.1

iOS Simulator SDKs:
	Simulator - iOS 12.1          	-sdk iphonesimulator12.1

macOS SDKs:
	macOS 10.14                   	-sdk macosx10.14

tvOS SDKs:
	tvOS 12.1                     	-sdk appletvos12.1

tvOS Simulator SDKs:
	Simulator - tvOS 12.1         	-sdk appletvsimulator12.1

watchOS SDKs:
	watchOS 5.1                   	-sdk watchos5.1

watchOS Simulator SDKs:
	Simulator - watchOS 5.1       	-sdk watchsimulator5.1

➜  ~
</code></pre>
<p>把模擬器的 SDK 記下來（這裡是 <code>iphonesimulator12.1</code>），接下來切換到 app source code 的根目錄，執行以下指令包出 app。</p>
<pre><code class="language-bash">xcodebuild -sdk iphonesimulator12.1 -workspace &lt;Workspace File&gt;.xcworkspace -scheme &lt;Scheme Name&gt; -derivedDataPath ~/Documents/DerivedData COMPILER_INDEX_STORE_ENABLE=NO | xcpretty
</code></pre>
<p>這裡有幾個要注意的參數：</p>
<ul>
<li><code>-sdk</code> 後面的參數就是剛才記下來的模擬器 SDK。</li>
<li><code>-workspace</code> 後面的參數要包含 <code>.xcworkspace</code> 副檔名。</li>
<li><code>-scheme</code> 指定我們要的 scheme 設定。</li>
<li><code>-derivedDataPaht</code> 指定編譯過程產生的檔案要放在哪裡，為了比較好找到我們包出來的 <code>.app</code> 檔，所以我指定到我的 Documents 底下。這樣 <code>.app</code> 檔就會存在 <code>~/Documents/DerivedData/Build/Products/Debug-iphonesimulator/</code> 底下。</li>
<li><code>COMPILER_INDEX_STORE_ENABLE=NO</code> 避免在 compile 的時候做 indexing，可縮短 build time。</li>
<li><code>| xcpretty</code> 是把產生的 log 導到 <a href="https://github.com/xcpretty/xcpretty">xcpretty</a>，讓 log 以比較好讀的格式呈現。可以透過 <code>gen install xcpretty</code> 安裝這個工具，這個設定不是必要的。</li>
</ul>
<h3 id="撰寫第一個測試">撰寫第一個測試</h3>
<p>首先建立一個 <code>app_config.py</code>，輸入以下內容，這個檔案指定了接下來會用到的一些設定。注意裡頭有些地方要改成你自己的設定（例如 <code>app_path</code> 的值）。</p>
<pre><code class="language-python">command_executor = &quot;http://127.0.0.1:4723/wd/hub&quot;
app_path = &quot;/path/to/your/app/name.app&quot;

simulator_caps_iphone_se = {
    &quot;platformVersion&quot;: &quot;12.1&quot;,
    &quot;deviceName&quot;: &quot;iPhone SE&quot;
}

desired_capabilities = {
    **simulator_caps_iphone_se,
    &quot;app&quot;: app_path,
    &quot;platformName&quot;: &quot;iOS&quot;,
    &quot;automationName&quot;: &quot;XCUITest&quot;,
    &quot;autoAcceptAlerts&quot;: False,
    &quot;sendKeyStrategy&quot;: &quot;grouped&quot;,
    &quot;permissions&quot;: &quot;{\&quot;your.app.bundle.id\&quot;:{\&quot;camera\&quot;:\&quot;YES\&quot;,\&quot;medialibrary\&quot;:\&quot;YES\&quot;,\&quot;microphone\&quot;:\&quot;YES\&quot;,\&quot;notifications\&quot;:\&quot;YES\&quot;,\&quot;photos\&quot;:\&quot;YES\&quot;}}&quot;
}
</code></pre>
<p>我們建立一個 <code>ui_testing.py</code> 來撰寫測試程式碼。這裡要注意的是，我們使用 <code>setUpClass()</code> 跟 <code>tearDownClass()</code> 而不是一般 tutorial 用到的 <code>setUp()</code> 跟 <code>tearDown()</code>，原因在於如果使用後者，每一個 test case 都會重新安裝 app 從頭來過。</p>
<p>還有一點要注意的是，每個 test case function 都是以 <code>test</code> 命名開頭，它會自動把這些 test case function 依名稱排序執行。但因為我們是 UI Test，每個測試之間有很強的順序性，所以我們在命名加上了序號，讓它依照我們想要的順序執行。</p>
<pre><code class="language-python">import unittest
from appium import webdriver
from time import sleep
from selenium.common.exceptions import NoSuchElementException
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as ec
from selenium.webdriver.support.ui import WebDriverWait

from app_config import *

class MyTests(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.driver = webdriver.Remote(command_executor, desired_capabilities)

    @classmethod
    def tearDownClass(cls):
        cls.driver.quit()

    def test_1_FirstTest(self):
        result = True
        self.assertTrue(result)

    def test_2_Second(self):
        result = True
        self.assertTrue(result)

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(MyTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>
<p>最後記得啟動你的 Appium Server，然後在 Terminal 輸入以下指令就可以開始我們的第一個測試了。</p>
<pre><code class="language-bash">pytest ui_testing.py
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS App 如何支援 RTL 語言]]></title>
        <id>https://chiahsien.github.io/post/how-to-support-rtl-languages-in-ios-app/</id>
        <link href="https://chiahsien.github.io/post/how-to-support-rtl-languages-in-ios-app/">
        </link>
        <updated>2019-02-24T17:10:44.000Z</updated>
        <summary type="html"><![CDATA[<p>公司的產品越做越大，前一陣子幫公司的 app 加上阿拉伯文介面，開發過程也累積了一些支援 RTL 語系的心得，藉這個機會跟大家分享。</p>
]]></summary>
        <content type="html"><![CDATA[<p>公司的產品越做越大，前一陣子幫公司的 app 加上阿拉伯文介面，開發過程也累積了一些支援 RTL 語系的心得，藉這個機會跟大家分享。</p>
<!-- more -->
<h2 id="找到-native-speaker">找到 Native Speaker</h2>
<p>對於書寫方向是「從左到右」的我們來說，最困難的其實不是看不懂這個語言，而是不知道這樣的 layout 是否正確，因為 layout 絕對不是全部都無腦的換成「從右到左」就好。所以如果情況許可，最好找個 native speaker 讓團隊諮詢（例如找個當地的員工，或是請當地大學生來打工之類），這樣可以節省不少來回確認界面的時間。</p>
<h2 id="仔細閱讀蘋果文件">仔細閱讀蘋果文件</h2>
<p>很多開發的注意事項都寫在這份<a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/SupportingRight-To-LeftLanguages/SupportingRight-To-LeftLanguages.html">蘋果文件</a>裡頭了，開發前跟開發時務必要多次閱讀，會有很大的幫助。另外，不只是 RD 需要閱讀這份文件，PM、QA、Designer 也應該看過，才不會發生 RD 做出正確界面，結果其他人以為是錯的（例如多媒體播放器的控制元件是不需要 RTL 的）。</p>
<h2 id="程式開發的一些小技巧">程式開發的一些小技巧</h2>
<h3 id="圖片左右翻轉">圖片左右翻轉</h3>
<p>如果有特殊需求的話，可以考慮對圖片 localized，這樣就可以提供適當翻轉過的圖片給特定語言，或是你也可以透過程式碼去翻轉圖片。但是假如你需要的就只是左右翻轉的圖片（例如 arrow 或 bullet-list 的圖片），可以很簡單的透過以下方式取得：</p>
<pre><code class="language-objc">UIImage *image = [UIImage imageNamed:@&quot;xxx&quot;];
// 對圖片做一些必要處理
// .....
// 最後再翻轉圖片
image = [image imageFlippedForRightToLeftLayoutDirection];
</code></pre>
<p>要注意的是，翻轉一定要放在最後一步，這樣才會得到預期結果。</p>
<h3 id="使用-auto-layout-及相關技術">使用 Auto Layout 及相關技術</h3>
<p>正確使用 auto layout 的 <code>leading</code> 跟 <code>trailing</code>，加上將 <code>textAlignment</code> 設為 <code>NSTextAlignmentNatural</code>，就可以解決九成以上的 RTL 佈局。如果你的程式還沒支援 auto layout，可以趁機逐步轉換過去。</p>
<h3 id="手動計算-frame">手動計算 Frame</h3>
<p>由於種種因素讓你還無法轉成 auto layout（例如為了效能考量，或是有些地方就是用 frame 比較容易，或是轉換成本太大），這時候你就需要判斷現在是否在 RTL 環境來調整 frame。</p>
<pre><code class="language-objc">if ([UIView userInterfaceLayoutDirectionForSemanticContentAttribute:view.semanticContentAttribute] == UIUserInterfaceLayoutDirectionRightToLeft) {
    // RTL 佈局
} else {
    // LTR 佈局
}
</code></pre>
<h3 id="翻轉再翻轉">翻轉再翻轉</h3>
<p>還有一種情況是不方便用 auto layout，但是手動計算 frame 又有很多額外因素要考量讓你不想計算。舉個常見的例子：有上下兩個可以左右滑動的 scroll view，上面是多個 tab，下面是點選 tab 之後要捲動到特定範圍。常見的做法是上方每個 tab 都有一個 index，下方則是根據選中的 index 計算 <code>contentOffset</code>。在 RTL 並且要手動計算 frame 的情況下，你會發現 index 處理起來很麻煩。</p>
<p>這裡有一個小技巧，我們可以先對最外層的 container view（例如 <code>UIScrollView</code>）左右翻轉，然後再對 subviews 左右翻轉一次。經過兩次翻轉，這些 subviews 就會從右到左排列，而且原有的程式碼幾乎不需要改動。這招或許看起來很 tricky，但它真的很有用，用得好可以節省非常多的時間。</p>
<pre><code class="language-objc">if ([UIView userInterfaceLayoutDirectionForSemanticContentAttribute:view.semanticContentAttribute] == UIUserInterfaceLayoutDirectionRightToLeft) {
    scrollView.transform = CGAffineTransformMakeScale(-1, 1);
    for (UIView *subview in scrollView.subviews) {
        subview.transform = CGAffineTransformMakeScale(-1, 1);
    }
}
</code></pre>
<p>以上就是我們在支援 RTL 時用到的所有方式，希望對大家有幫助。</p>
]]></content>
    </entry>
</feed>